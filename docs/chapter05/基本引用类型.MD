### 一、Date
1. #### new Date
   创建日期，不传入参数，则创建当前日期

2. #### Date.parse
   传入指定格式的日期参数转为毫秒值，支持以下格式
   - “月/日/年”，如"5/23/2019"；

   - “月名 日, 年”，如"May 23, 2019"；
   - “周几 月名 日 年 时:分:秒 时区”，如"Tue May 23 2019 00:00:00 GMT-0700"；
   -  ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容 ES5 的实现）

3. #### Date.UTC
   同Date.parse,把指定格式的日期转为毫秒值,但使用不同的格式。参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。

   ```javascript
   // GMT 时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒
   let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
   ```

   

4. #### Date.now
   当前日期的毫秒值

5. #### 继承的方法
   - valueOf

   - toString
   - toLocaleString

6. #### 日期格式化方法
   - toDateString()显示日期中的周几、月、日、年（格式特定于实现）；

   - toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；
   - toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；
   - toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；
   - toUTCString()显示完整的 UTC 日期（格式特定于实现）。
   这些方法的输出与 toLocaleString()和 toString()一样，会因浏览器而异。因此不能用于在
   用户界面上一致地显示日期。

7. #### 日期/时间组件方法

- 获取/设置: 毫秒值，年、月、日、小时、分钟、秒、毫秒、星期几
- 返回以分钟计的 UTC 与本地时区的偏移量

### 二、ExpReg
ECMAScript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：
let expression = /pattern/flags; 
这个正则表达式的** pattern（模式）**可以是任何简单或复杂的正则表达式，包括`字符类、限定符、分组、向前查找和反向引用`。每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。

- g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
- i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
- m：多行模式，表示查找到一行文本末尾时会继续查找。
- y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
- u：Unicode 模式，启用 Unicode 匹配。
- s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。

1. #### 实例属性
每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。
 global：布尔值，表示是否设置了 g 标记。
 ignoreCase：布尔值，表示是否设置了 i 标记。
 unicode：布尔值，表示是否设置了 u 标记。
 sticky：布尔值，表示是否设置了 y 标记。
 lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。
 multiline：布尔值，表示是否设置了 m 标记。
 dotAll：布尔值，表示是否设置了 s 标记。
 source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的
斜杠。
 flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没
有前后斜杠）。
通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含
这些信息。下面是一个例子：
```javascript
let pattern1 = /\[bc\]at/i; 
console.log(pattern1.global); // false 
console.log(pattern1.ignoreCase); // true 
console.log(pattern1.multiline); // false 
console.log(pattern1.lastIndex); // 0 
console.log(pattern1.source); // "\[bc\]at" 
console.log(pattern1.flags); // "i" 
let pattern2 = new RegExp("\\[bc\\]at", "i"); 
console.log(pattern2.global); // false 
console.log(pattern2.ignoreCase); // true 
console.log(pattern2.multiline); // false 
console.log(pattern2.lastIndex); // 0 
console.log(pattern2.source); // "\[bc\]at" 
console.log(pattern2.flags); // "i" 
```
注意，虽然第一个模式是通过字面量创建的，第二个模式是通过 RegExp 构造函数创建的，但两个
模式的 source 和 flags 属性是相同的。source 和 flags 属性返回的是规范化之后可以在字面量中
使用的形式。
2. #### 实例方法

   - exec
    RegExp 实例的主要方法是 exec()，主要用于**配合捕获组使用**。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。*这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串*。如果模式中没有捕获组，则数组只包含一个元素
```javascript
    //  1>不设置全局模式
		//	无论执行多少次都是同一个结果
 	    let text = "cat, bat, sat, fat"; 
        let pattern = /.at/g; 
        let matches = pattern.exec(text); 
        console.log(matches.index); // 0 
        console.log(matches[0]); // cat 
        console.log(pattern.lastIndex); // 3 
        matches = pattern.exec(text); 
	    console.log(matches.index); // 0 
        console.log(matches[0]); // cat 
        console.log(pattern.lastIndex); // 3 
    //  2>设置全局模式
        let text = "cat, bat, sat, fat"; 
        let pattern = /.at/g; 
        let matches = pattern.exec(text); 
        console.log(matches.index); // 0 
        console.log(matches[0]); // cat 
        console.log(pattern.lastIndex); // 3 
        matches = pattern.exec(text); 
        console.log(matches.index); // 5 
        console.log(matches[0]); // bat 
        console.log(pattern.lastIndex); // 8 
        matches = pattern.exec(text); 
        console.log(matches.index); // 10 
        console.log(matches[0]); // sat 
        console.log(pattern.lastIndex); // 13 
    //  3>与设置y粘性匹配对比
        let text = "cat, bat, sat, fat"; 
        let pattern = /.at/y; 
        let matches = pattern.exec(text); 
        console.log(matches.index); // 0 
        console.log(matches[0]); // cat 
        console.log(pattern.lastIndex); // 3 
        // 以索引 3 对应的字符开头找不到匹配项，因此 exec()返回 null 
        // exec()没找到匹配项，于是将 lastIndex 设置为 0 
        matches = pattern.exec(text); 
        console.log(matches); // null 
        console.log(pattern.lastIndex); // 0 
        // 向前设置 lastIndex 可以让粘附的模式通过 exec()找到下一个匹配项：
        pattern.lastIndex = 5; 
        matches = pattern.exec(text); 
        console.log(matches.index); // 5 
        console.log(matches[0]); // bat 
        console.log(pattern.lastIndex); // 8 
    //  4>与match对比
 	    let text = "cat, bat, sat, fat"; 
        let pattern = /.at/g; 
        let matches = text.match(pattern); 
        console.log(matches); //  ["cat", "bat", "sat", "fat"] 
```

   - test
      接收一个字符串参数。如果输入的文本与模式匹配，则参数 返回 true，否则返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。

3. #### RexExp构造函数属性
  构造函数本身也有几个属性，在其他语言里称为静态属性。

  ![image-20210415140256243](../images/image-20210415140256243.png)

  ```javascript
  // 使用全名
  let text = "this has been a short summer"; 
  let pattern = /(.)hort/g; 
  if (pattern.test(text)) { 
   console.log(RegExp.input); // this has been a short summer 
   console.log(RegExp.leftContext); // this has been a 
   console.log(RegExp.rightContext); // summer 
   console.log(RegExp.lastMatch); // short 
   console.log(RegExp.lastParen); // s 
  } 
  
  // 使用简写
  let text = "this has been a short summer"; 
  let pattern = /(.)hort/g; 
  /* 
   * 注意：Opera 不支持简写属性名
   * IE 不支持多行匹配
   */ 
  if (pattern.test(text)) { 
   console.log(RegExp.$_); // this has been a short summer 
   console.log(RegExp["$`"]); // this has been a 
   console.log(RegExp["$'"]); // summer 
   console.log(RegExp["$&"]); // short 
   console.log(RegExp["$+"]); // s 
  } 
  
  
  ```

  RegExp 还有其他几个构造函数属性，可以存储最多 9 个捕获组的匹配项。这些属性通过 RegExp.$1~RegExp.$9 来访问，分别包含第 1~9 个捕获组的匹配项
### 三、原始值包装类型
### 四、单例内置对象