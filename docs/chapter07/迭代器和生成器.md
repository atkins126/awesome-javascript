### 实现了Iterable接口的内置类型
- 字符串
- 数组
- 映射
- 集合
- arguments 对象
- NodeList 等 DOM 集合类型
这些类型都实现了迭代器工厂函数，以`Symbol.iterator`为键暴露默认迭代器，这个默认迭代器属性引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。
实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：
- for-of 循环
- 数组解构
- 扩展操作符
- Array.from()
- 创建集合
- 创建映射
- Promise.all()接收由期约组成的可迭代对象
- Promise.race()接收由期约组成的可迭代对象
- yield*操作符，在生成器中使用
这些原生语言结构会**在后台调用**提供的可迭代对象的这个工厂函数，从而创建一个迭代器

### 自定义迭代器，以下2种创建方式比较:
1. 
```javascript
class Counter { 
 // Counter 的实例应该迭代 limit 次
 constructor(limit) { 
 this.count = 1; 
 this.limit = limit; 
 } 
 next() { 
 if (this.count <= this.limit) { 
 return { done: false, value: this.count++ }; 
 } else { 
 return { done: true, value: undefined }; 
 } 
 } 
 [Symbol.iterator]() { // 返回this对象，this里有next方法
 return this; 
 } 
} 
let counter = new Counter(3); 
for (let i of counter) { // for...of会自动执行工厂函数，函数执行返回一个对象，即迭代器，然后继续自动执行迭代器的next方法
 console.log(i); 
} 
// 1 
// 2 
// 3 
```
这种只能不理想，它的实例只能被迭代一次
2. 
```javascript
class Counter { 
 constructor(limit) { 
 this.limit = limit; 
 } 
 [Symbol.iterator]() { // 执行后返回一个对象，带next方法，使用for...of时会自动执行这个工厂函数，并执行工厂函数返回的对象的next方法
 let count = 1, 
 limit = this.limit; 
 return { 
 next() { 
 if (count <= limit) { 
 return { done: false, value: count++ }; 
 } else { 
 return { done: true, value: undefined }; 
 } 
 } 
 }; 
 } 
} 
let counter = new Counter(3); 
for (let i of counter) { console.log(i); } 
// 1 
// 2 
// 3 
for (let i of counter) { console.log(i); } 
// 1 
// 2 
// 3 

```
重写String的迭代接口（测试）
```javascript
String.prototype[Symbol.iterator] = function iterator (){
let current = 0;
let _this = this
let next = function(){
let done = current >= _this.length
return {value: _this[done ? current : current++], done }
}
return {
  [Symbol.iterator]() {return this},
  next,
  // return() { 
  //   console.log('结束了'); 
  //   return { done: true }; 
  //   }
  // }
}
var s = 'yh'
for(let i of s){console.log(i)}
// y
// h

var i1 = s[Symbol.iterator]()
for(let i of i1){console.log(i)}
// y
// h

var i2 = i1[Symbol.iterator]()
i2 === i1 // true

var i3 = s[Symbol.iterator]()
i3.next() // y
for(let i of i3){console.log(i)} // 因为前面已经执行了next，再使用for...of就只有h输出了
// h
```
### 提前终止迭代器
可选的 **return()**方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括：
- for-of 循环通过 `break`、`continue`、`return` 或 `throw` 提前退出；
- `解构操作`并未消费所有值。
return()方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回{ done: true }。因为这个返回值只会用在生成器的上下文中。如下面的代码所示，内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用return()方法。
```javascript
class Counter { 
 constructor(limit) { 
 this.limit = limit; 
 } 
 [Symbol.iterator]() { 
 let count = 1, 
 limit = this.limit; 
 return { 
 next() { 
 if (count <= limit) { 
 return { done: false, value: count++ }; 
 } else { 
 return { done: true }; 
 } 
 }, 
 return() { 
 console.log('Exiting early'); 
 return { done: true }; 
 } 
 }; 
 } 
} 
let counter1 = new Counter(5); 
for (let i of counter1) { 
 if (i > 2) { 
 break; 
 } 
 console.log(i); 
} 
// 1 
// 2 
// Exiting early 
let counter2 = new Counter(5); 
try { 
 for (let i of counter2) { 
 if (i > 2) { 
 throw 'err'; 
 } 
 console.log(i); 
 } 
} catch(e) {} 
// 1 
// 2 
// Exiting early 
let counter3 = new Counter(5); 
let [a, b] = counter3; 
// Exiting early 
```
如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，**数组的迭代器就是不能关闭的**。
```javascript
let a = [1, 2, 3, 4, 5]; 
let iter = a[Symbol.iterator](); 
for (let i of iter) { 
 console.log(i); 
 if (i > 2) { 
 break 
 } 
} 
// 1 
// 2 
// 3 
for (let i of iter) { 
 console.log(i); 
} 
// 4 
// 5 

```
因为 return()方法是可选的，所以**并非所有迭代器都是可关闭的**。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用 return()不会强制迭代器进入关闭状态。即便如此，return()方法还是会被调用。
```javascript
let a = [1, 2, 3, 4, 5]; 
let iter = a[Symbol.iterator](); 
iter.return = function() { 
 console.log('Exiting early'); 
 return { done: true }; 
 }; 
for (let i of iter) { 
 console.log(i); 
 if (i > 2) { 
 break 
 } 
} 
// 1 
// 2 
// 3 
// 提前退出
for (let i of iter) { 
 console.log(i); 
} 
// 4 
// 5 

```