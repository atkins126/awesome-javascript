实现了Iterable接口的内置类型：
- 字符串
- 数组
- 映射
- 集合
- arguments 对象
- NodeList 等 DOM 集合类型
这些类型都实现了迭代器工厂函数，以`Symbol.iterator`为键暴露默认迭代器，这个默认迭代器属性引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。
实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：
- for-of 循环
- 数组解构
- 扩展操作符
- Array.from()
- 创建集合
- 创建映射
- Promise.all()接收由期约组成的可迭代对象
- Promise.race()接收由期约组成的可迭代对象
- yield*操作符，在生成器中使用
这些原生语言结构会**在后台调用**提供的可迭代对象的这个工厂函数，从而创建一个迭代器

自定义迭代器，以下2种创建方式比较:
1. 
```javascript
class Counter { 
 // Counter 的实例应该迭代 limit 次
 constructor(limit) { 
 this.count = 1; 
 this.limit = limit; 
 } 
 next() { 
 if (this.count <= this.limit) { 
 return { done: false, value: this.count++ }; 
 } else { 
 return { done: true, value: undefined }; 
 } 
 } 
 [Symbol.iterator]() { // 返回this对象，this里有next方法
 return this; 
 } 
} 
let counter = new Counter(3); 
for (let i of counter) { // for...of会自动执行工厂函数，函数执行返回一个对象，即迭代器，然后继续自动执行迭代器的next方法
 console.log(i); 
} 
// 1 
// 2 
// 3 
```
这种只能不理想，它的实例只能被迭代一次
2. 
```javascript
class Counter { 
 constructor(limit) { 
 this.limit = limit; 
 } 
 [Symbol.iterator]() { // 执行后返回一个对象，带next方法，使用for...of时会自动执行这个工厂函数，并执行工厂函数返回的对象的next方法
 let count = 1, 
 limit = this.limit; 
 return { 
 next() { 
 if (count <= limit) { 
 return { done: false, value: count++ }; 
 } else { 
 return { done: true, value: undefined }; 
 } 
 } 
 }; 
 } 
} 
let counter = new Counter(3); 
for (let i of counter) { console.log(i); } 
// 1 
// 2 
// 3 
for (let i of counter) { console.log(i); } 
// 1 
// 2 
// 3 

```
重写String的迭代接口（测试）
```javascript
String.prototype[Symbol.iterator] = function iterator (){
let current = 0;
let _this = this
let next = function(){
let done = current >= _this.length
return {value: _this[done ? current : current++], done }
}
return {
  [Symbol.iterator]() {return this},
  next
  }
}
var s = 'yh'
for(let i of s){console.log(i)}
// y
// h

var i1 = s[Symbol.iterator]()
for(let i of i1){console.log(i)}
// y
// h

var i2 = i1[Symbol.iterator]()
i2 === i1 // true

var i3 = s[Symbol.iterator]()
i3.next() // y
for(let i of i3){console.log(i)} // 因为前面已经执行了next，再使用for...of就只有h输出了
// h
```